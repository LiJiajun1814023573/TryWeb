# Day Eleven
****
## learning hours:
* 16-18 19-22
## What I Have Learned: 
* 学习Promise的u实现,理解了Promise的适用场景与应用原因.
* 学习语法糖async,await以及gitignore.
* 学习了es6特性.
## Progress of the Task: 
* task1部分
## The Study Plan:
* 明天学习内容结束后如果有时间尝试做一下task2.
## Problems:
* 对于promise,之前已经基本会使用了,但是对于Promise一直不理解为什么要使用,就是因为总认为有些方法可以替代promise. 从而再认真学习了一下,目前的认识是:
    * 首先是,Promise解决了回调地狱的问题,避免层层嵌套的回调,但是回调地狱真的只有Promise能解决吗?不一定,单纯的function分离也可以实现.但后来想想,这种方式也存在问题,即:代码复用性不高的情况下,单独分离写function对于开发而言效率不高,并且不利于维护.
    * 另外一方面:promise相较于function分离的方式,还具有灵活性,then方法内如何对值进行处理,完全取决于传递给then的回调函数,而function每次得重新写一个,并不便捷.
    * 实现了:错误捕获问题的解决.正常的异步操作如果是失败并在内部抛出异常(如定时器函数内),外部无法捕获异常.promise的出现,使得可以通过改变状态,(尽管改变状态操作reject()出现在异步操作中),使得错误仍然能够因状态改变而被捕获.从而执行了失败的回调或者进行处理.
    * 还有一点:不知道理解的正确与否. 拿promisie的一些静态方法,如promise.all来看,它的好处是什么?我们可能会听过它是为了并发执行,可是关键点是否在于并发执行呢?并且对于以前的我来说,这种说法很容易产生误解.首先并发不是并行,但可能不必抠概念.单从实现的效果来看,promise.all中如果有多个异步任务,还是会依次挂起,然后依次执行.所以如果理解为同一瞬间开始挂起或者执行就有问题了(这从事件循环的角度以及实现promise.all的角度也能看出问题)...除此之外,我认为就promise.all而言,它最大的优势应该在于能够保证all内所有的任务都执行完再执行下一步.如果抛去这一点,或许它与普通的for循环串行调用(仍然可以是如果碰到异步任务依次挂起,但不能保证所有任务执行完再开始后续操作)没有本质区别,只有一个形式差异.整合数据应该是次要的优点.
* 固然promise的好处应该不止这些,虽然我在看一些例子的时候总会想着这种功能或许可以用其他更好方式实现的想法. 

* 但是promise能够被接受必然有其道理,我理解的不够或许是因为积累的经验不足,如果能在不同场合多尝试不同方式,或许不同方法之间孰好孰坏才能辨明.同时在不同场合应用不同方法
